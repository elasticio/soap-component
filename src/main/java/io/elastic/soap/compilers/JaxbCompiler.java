package io.elastic.soap.compilers;

import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.predic8.wsdl.Binding;
import com.predic8.wsdl.BindingOperation;
import com.predic8.wsdl.Definitions;
import com.predic8.wsdl.Message;
import com.predic8.wsdl.WSDLParser;
import io.elastic.soap.AppConstants;
import io.elastic.soap.compilers.generators.IJaxbGenerator;
import io.elastic.soap.compilers.generators.JaxbGeneratorModule;
import io.elastic.soap.compilers.generators.impl.Axis2GeneratorImpl;
import io.elastic.soap.compilers.model.SoapBodyDescriptor;
import io.elastic.soap.utils.Utils;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class JaxbCompiler {

  @Inject
  private static IJaxbGenerator generator;

  private static final Logger logger = LoggerFactory.getLogger(JaxbCompiler.class);

  private static Map<String, String> isWsdlCompiledMap = new HashMap<>();
  private static Map<String, Definitions> loadedDefsMap = new HashMap<>();

  /**
   * Check directory for generating JAXB classes in. If it does not exist, create it.
   */
  static {
    createFolder(AppConstants.GENERATED_RESOURCES_DIR);
  }

  /**
   * Creates {@link Injector} in order to inject needed implementation of {@link IJaxbGenerator}
   */
  static {
    generator = injectJaxbGeneratorModule(Axis2GeneratorImpl.class);
  }

  /**
   * Check directory for generating JAXB classes in. If it does not exist, create it.
   */
  public static void createFolder(String path) {
    File dir = new File(path);
    if (!dir.exists()) {
      dir.mkdir();
      logger.info("Directory {} successfully created.", AppConstants.GENERATED_RESOURCES_DIR);
    }
  }

  /**
   * Generates JAXB structure and loads it into classpath
   */
  public static void generateAndLoadJaxbStructure(String wsdlUrl) throws Throwable {
    generator.generateJaxbClasses(wsdlUrl, isWsdlCompiledMap);
    loadClassesInDirToClassloader();
  }

  /**
   * Method filters out all the bindings and operations except for the input one pair.
   *
   * @param defs {@link Definitions} object of the parsed WSDL
   * @param binding Binding name
   * @param operation Operation name
   * @return {@link BindingOperation} object
   */
  public static BindingOperation getBindingOperation(Definitions defs, String binding,
      String operation) {
    List<Binding> bindingList = defs.getBindings();
    return bindingList.stream()
        .filter(bind -> bind.getName().equals(binding))
        .findAny().get()
        .getOperations().stream()
        .filter(bindingOp -> bindingOp.getName().equals(operation))
        .findAny().get();
  }

  /**
   * Method parses the WSDL for the given bending/operation pair, creates and returns a {@link
   * SoapBodyDescriptor} object containing this data combination
   */
  public static SoapBodyDescriptor getSoapBodyDescriptor(String wsdlUrl, String binding,
      String operation) {
    Definitions defs = loadedDefsMap.get(wsdlUrl);
    if (defs == null) {
      defs = new JaxbCompiler().getDefinitionsFromWsdl(wsdlUrl);
      loadedDefsMap.put(wsdlUrl, defs);
    }
    BindingOperation bindingOperation = getBindingOperation(defs, binding, operation);
    String soapAction = bindingOperation.getOperation().getSoapAction();
    String soapEndPoint = defs.getServices().stream()
        .flatMap(service -> service.getPorts().stream())
        .filter(port -> port.getBinding().getName().equals(binding)).findAny().get().getAddress()
        .getLocation();
    Message inputMessage = (Message) bindingOperation.getInput().getProperty("message");
    Message outputMessage = (Message) bindingOperation.getOutput().getProperty("message");

    return buildSoapBodyDescriptor(inputMessage, outputMessage, binding, operation, soapAction,
        soapEndPoint);
  }

  /**
   * Creates {@link Injector} in order to inject needed implementation of {@link IJaxbGenerator}
   */
  public static IJaxbGenerator injectJaxbGeneratorModule(Class clazz) {
    Injector injector = Guice.createInjector(new JaxbGeneratorModule());
    return (IJaxbGenerator) injector.getInstance(clazz);
  }

  /**
   * Classes, generated by {@link IJaxbGenerator#generateJaxbClasses(String, Map)} should be loaded
   * into classloader in order to be accessible
   */
  public static void loadClassesInDirToClassloader()
      throws ClassNotFoundException, MalformedURLException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    logger.info("About to start loading generated JAXB classes into class loader");
    File file = new File(AppConstants.GENERATED_RESOURCES_DIR);
    URL url = file.toURI().toURL();
    URLClassLoader urlClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();
    Class urlClass = URLClassLoader.class;
    Method method = urlClass.getDeclaredMethod("addURL", new Class[]{URL.class});
    method.setAccessible(true);
    method.invoke(urlClassLoader, new Object[]{url});
    logger.info("Loading generated JAXB classes into class loader successfully done");
  }

  /**
   * Service method to set an instance of {@link SoapBodyDescriptor} object with values
   *
   * @return Fully built and ready to use {@link SoapBodyDescriptor} object
   */
  private static SoapBodyDescriptor buildSoapBodyDescriptor(Message inputMessage,
      Message outputMessage,
      String binding, String operation, String soapAction, String soapEndPoint) {
    SoapBodyDescriptor soapBodyDescriptor = new SoapBodyDescriptor();
    soapBodyDescriptor.setBindingName(binding);
    soapBodyDescriptor.setOperationName(operation);
    soapBodyDescriptor.setSoapAction(soapAction);
    soapBodyDescriptor.setSoapEndPoint(soapEndPoint);

    String elementName = inputMessage.getParts().get(0).getElement().getName();
    soapBodyDescriptor.setRequestBodyElementName(elementName);
    soapBodyDescriptor
        .setRequestBodyPackageName(Utils.convertToPackageName(inputMessage.getNamespaceUri()));
    soapBodyDescriptor.setRequestBodyNameSpace(outputMessage.getNamespaceUri());
    soapBodyDescriptor.setRequestBodyClassName(getClassName(inputMessage, elementName));

    elementName = outputMessage.getParts().get(0).getElement().getName();
    soapBodyDescriptor.setResponseBodyElementName(elementName);
    soapBodyDescriptor
        .setResponseBodyPackageName(Utils.convertToPackageName(outputMessage.getNamespaceUri()));
    soapBodyDescriptor.setResponseBodyNameSpace(outputMessage.getNamespaceUri());
    soapBodyDescriptor.setResponseBodyClassName(getClassName(outputMessage, elementName));

    return soapBodyDescriptor;
  }

  /**
   * Some XSD schemas have elements with its types, some - have no types. In order to parse all the
   * elements properly, this method takes either element name or type name.
   *
   * @param msg WSDL {@link Message} representation
   * @param elementName The name of the element which type or element name should be retieved
   * @return Element or type name
   */
  private static String getClassName(Message msg, String elementName) {
    String className;
    if (msg.getParts().get(0).getElement().getType() == null) {
      className = Utils.getWithUpperFirstLetter(elementName);
    } else {
      className = msg.getParts().get(0).getElement().getType().getLocalPart();
      className = Utils.getWithUpperFirstLetter(className);
    }
    return Utils.convertToPackageName(msg.getNamespaceUri()) + "." + className;
  }

  /**
   * Method calls external WSDL by its URL and parses it
   *
   * @return {@link Definitions} object
   */
  public Definitions getDefinitionsFromWsdl(String wsdlUrl) {
    WSDLParser parser = new WSDLParser();
    return parser.parse(wsdlUrl);
  }
}
